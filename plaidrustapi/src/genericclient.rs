#[allow(dead_code)]
#[derive(Clone)]
pub struct Client {
    client_id: String,
    secret: Secret,
    url: String,
    client: ReqwestClient,
}

impl Client {
    /// Creates a new `Client`.
    #[allow(dead_code)]
    pub fn new<C, S>(client_id: C, secret: S, environment: Environment) -> Client
    where
        C: Into<String>,
        S: Into<Secret>,
    {
        Client {
            client_id: client_id.into(),
            secret: secret.into(),
            url: format!("https://{}.plaid.com", environment),
            client: ReqwestClient::builder()
                .connect_timeout(Duration::from_secs(30))
                .build()
                .expect("could not create Reqwest client"),
        }
    }

    /// Creates a new `Client` from the following environment variables:
    /// - `PLAID_CLIENT_ID`
    /// - `PLAID_SECRET`
    /// - `PLAID_ENVIRONMENT`
    #[allow(dead_code)]
    pub fn from_env() -> Result<Client, Box<dyn std::error::Error>> {
        let client = Client::new(
            env::var("PLAID_CLIENT_ID")?,
            env::var("PLAID_SECRET")?,
            env::var("PLAID_ENVIRONMENT")?.parse()?,
        );
        Ok(client)
    }

    /// Create a test Item
    ///
    /// [/sandbox/public_token/create]
    ///
    /// Use the [/sandbox/public_token/create] endpoint to create a valid
    /// public_token for an arbitrary institution ID, initial products, and test
    /// credentials. The created public_token maps to a new Sandbox Item. You
    /// can then call [/item/public_token/exchange] to exchange the
    /// `public_token` for an access_token and perform all API actions.
    /// [/sandbox/public_token/create] can also be used with the [`user_custom`]
    /// test username to generate a test account with custom data.
    ///
    /// [/sandbox/public_token/create]: https://plaid.com/docs/api/sandbox/#sandboxpublic_tokencreate
    /// [/item/public_token/exchange]: https://plaid.com/docs/api/tokens/#itempublic_tokenexchange
    /// [`user_custom`]: https://plaid.com/docs/sandbox/user-custom/
    #[allow(dead_code)]
    pub fn sandbox_create_public_token(
        &self,
        request: &SandboxCreatePublicTokenRequest,
    ) -> impl Future<Item = SandboxCreatePublicTokenResponse, Error = ReqwestError> {
        // TODO: figure out a better way to do this...
        let mut body = json!(request);
        body["client_id"] = json!(&self.client_id);
        body["secret"] = json!(&self.secret);

        self.client
            .post(&format!("{}/sandbox/public_token/create", self.url))
            .json(&body)
            .send()
            .and_then(|res| res.error_for_status())
            .and_then(|mut res| res.json())
            .from_err()
    }

    /// Create Link Token
    ///
    /// [/link/token/create]
    ///
    /// Creates a `link_token`, which is required as a parameter when
    /// initializing Link. Once Link has been initialized, it returns a
    /// `public_token`, which can then be exchanged for an `access_token` via
    /// [/item/public_token/exchange] as part of the [main Link flow].
    ///
    /// A `link_token` generated by [/link/token/create] is also used to
    /// initialize other Link flows, such as the update mode flow for tokens
    /// with expired credentials, or the Payment Initiation (Europe) flow.
    ///
    /// [/link/token/create]: https://plaid.com/docs/api/tokens/#linktokencreate
    /// [/item/public_token/exchange]: https://plaid.com/docs/api/tokens/#itempublic_tokenexchange
    /// [main Link flow]: https://plaid.com/docs/link/#link-flow
    #[allow(dead_code)]
    pub fn create_link_token(
        &self,
    ) -> impl Future<Item = CreateLinkTokenResponse, Error = ReqwestError> {
        let body = json!({
            "client_id": &self.client_id,
            "secret": &self.secret,
            "institution_id": "ins_1",
            "initial_products": ["auth", "identity"]
        });

        self.client
            .post(&format!("{}/link/token/create", self.url))
            .json(&body)
            .send()
            .and_then(|res| res.error_for_status())
            .and_then(|mut res| res.json())
            .from_err()
    }

     /// Fetch real-time liabilities data
    ///
    /// [/liabilities/get]
    ///
    /// Returns the real-time balance for each of an Item's accounts. While
    /// other endpoints may return a balance object, only this endpoint forces
    /// the available and current balance fields to be refreshed rather than
    /// cached. This endpoint can be used for existing Items that were added via
    /// any of Plaidâ€™s other products. This endpoint can be used as long as Link
    /// has been initialized with any other product, `balance` itself is not a
    /// product that can be used to initialize Link.
    ///
    /// [/liabilities/get]: https://plaid.com/docs/api/products/#liabilitiesget
    #[allow(dead_code)]
    pub async fn liabilities(
        &self,
        access_token: &str,
        options: LiabilitiesRequestOptions,
    ) -> Result<LiabilitiesResponse, ReqwestError> {
        let body = json!({
            "client_id": &self.client_id,
            "secret": &self.secret,
            "access_token": access_token,
            "options": options,
        });

        
        self.client
            .post(&format!("{}/liabilities/get", self.url))
            .json(&body)
            .send()
            .await?
            .error_for_status()?
            .json()
            .await
    }

/// Options for the `liabilities` request.
#[derive(Serialize, Default, Clone, Debug)]
pub struct LiabilitiesRequestOptions {
    /// A list of `account_ids` to retrieve for the Item.
    ///
    /// *Note*: An error will be returned if a provided `account_id` is not
    /// associated with the Item.
    #[serde(default, with = "super::serde_utils::default_on_null")]
    account_ids: Vec<String>,
}


}